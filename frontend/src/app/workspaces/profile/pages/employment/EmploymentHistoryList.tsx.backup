import { useEffect, useState, useCallback, useRef } from "react";

// EmploymentHistoryList — high-level overview
// - Shows the signed-in user's employment entries.
// - Supports add (navigates), edit (modal), and delete (confirm then remove).
// - Uses a delayed spinner to avoid flicker on fast networks.
// Notes for students: this file uses React hooks (useEffect/useCallback)
// and a ref to keep track of the previous user id so we don't refetch
// unnecessarily during quick auth transitions.
import { useLocation, useNavigate } from "react-router-dom";
import { useAuth } from "@shared/context/AuthContext";
import { useProfileChange } from "@shared/context";
import employmentService from "../../services/employment";
import { AddEmploymentDialog } from "../../components/dialogs/AddEmploymentDialog";
import { Box, Button, Typography, Paper, Stack } from "@mui/material";
import LoadingSpinner from "@shared/components/feedback/LoadingSpinner";
import { useErrorHandler } from "@shared/hooks/useErrorHandler";
import { ErrorSnackbar } from "@shared/components/feedback/ErrorSnackbar";
import { useConfirmDialog } from "@shared/hooks/useConfirmDialog";
import { Breadcrumbs } from "@shared/components/navigation";
import EmptyState from "@shared/components/feedback/EmptyState";
import { Work as WorkIcon } from "@mui/icons-material";
import type { EmploymentRow } from "../../types/employment";

export default function EmploymentHistoryList() {
  const { user, loading } = useAuth();
  const [entries, setEntries] = useState<EmploymentRow[] | null>(null);
  // Start false to avoid a visible flash on quick loads; we show the spinner only
  // if loading lasts longer than spinnerDelayMs.
  const [isLoading, setIsLoading] = useState(false);
  
  // Dialog state
  const [dialogOpen, setDialogOpen] = useState(false);
  const [dialogMode, setDialogMode] = useState<"add" | "edit">("add");
  const [selectedEntry, setSelectedEntry] = useState<EmploymentRow | undefined>();
  const { handleError, notification, closeNotification, showSuccess } =
    useErrorHandler();
  const { markProfileChanged } = useProfileChange();
  const { confirm } = useConfirmDialog();
  const navigate = useNavigate();
  const location = useLocation();

  const fetchEntries = useCallback(async () => {
    // Fetch the user's employment rows from the backend and update state.
    // - Avoid fetching while auth is still initializing.
    // - Show a delayed spinner (small UX tweak) to prevent brief flashes.
    // - On error, surface it via centralized error handler.
    // The function is memoized so it can be safely referenced in effects.
    // If you change dependencies, double-check the useEffect that triggers it.
    // If auth is still initializing, don't trigger a fetch yet.
    if (loading) {
      // ensure a spinner appears if auth loading takes noticeable time
      setIsLoading(true);
      return;
    }
    if (!user) {
      setEntries([]);
      setIsLoading(false);
      return;
    }

    // Small UX tweak: avoid showing the loading spinner for very short loads
    // to prevent layout flicker. Use a delayed spinner toggle.
    const spinnerDelayMs = 120;
    const spinnerTimer = setTimeout(() => setIsLoading(true), spinnerDelayMs);
    try {
      // clear any prior early-loading flag if auth finished quickly
      // (we'll clear in finally)
      const res = await employmentService.listEmployment(user.id);

      if (res.error) {
        console.error("fetchEntries error:", res.error);
        handleError(res.error);
        setEntries([]);
      } else {
        const rows = (res.data ?? []) as EmploymentRow[];
        setEntries(rows);
      }
    } catch (e) {
      console.error("Unexpected fetchEntries error", e);
      setEntries([]);
    } finally {
      clearTimeout(spinnerTimer);
      setIsLoading(false);
    }
  }, [user, loading, handleError]);
  // Include handleError in dependencies to avoid stale reference

  // Only refetch when the authenticated user changes (or when auth finishes).
  // Track the previous user id so we don't refetch multiple times during
  // quick mount/auth transitions which can make the page feel like it reloads.
  const prevUserIdRef = useRef<string | null>(null);
  useEffect(() => {
    if (loading) return;

    const currentUserId = user?.id ?? null;
    // If user became null, clear entries and spinner.
    if (!currentUserId) {
      prevUserIdRef.current = null;
      setEntries([]);
      setIsLoading(false);
      return;
    }

    // If the user id hasn't changed since last fetch, skip refetching.
    if (prevUserIdRef.current === currentUserId) return;
    prevUserIdRef.current = currentUserId;

    void fetchEntries();
  }, [user?.id, loading, fetchEntries]);

  // If we were navigated here with a success message in location.state, show
  // a centralized snackbar and then clear the state so it doesn't show again.
  useEffect(() => {
    const maybeState = location.state as { success?: string } | null;
    if (maybeState && maybeState.success) {
      showSuccess(maybeState.success);
      // Replace the history entry so the state is cleared
      navigate(location.pathname, { replace: true, state: {} });
    }
    // Only run on mount/navigation changes
  }, [location, navigate, showSuccess]);

  // Dialog handlers - defined before early return
  const handleOpenAddDialog = () => {
    setDialogMode("add");
    setSelectedEntry(undefined);
    setDialogOpen(true);
  };

  const handleOpenEditDialog = (entry: EmploymentRow) => {
    setDialogMode("edit");
    setSelectedEntry(entry);
    setDialogOpen(true);
  };

  const handleCloseDialog = () => {
    setDialogOpen(false);
    setSelectedEntry(undefined);
  };

  const handleDialogSuccess = () => {
    fetchEntries();
  };

  const handleDelete = async (entryId: string) => {
    // Confirm deletion with user using hook-based dialog
    const confirmed = await confirm({
      title: "Delete employment entry?",
      message: "This will permanently delete the selected employment entry.",
      confirmText: "Delete",
      confirmColor: "error",
    });

    if (!confirmed) return;

    if (!user) {
      handleError("Please sign in to delete entries.");
      return;
    }

    try {
      const res = await employmentService.deleteEmployment(user.id, entryId);
      if (res.error) {
        console.error(res.error);
        handleError(res.error);
      } else {
        // After a successful deletion, refresh the list so the UI reflects
        // the backend state. Then set navigation state so the list page shows
        // a centralized success snackbar (consistent notification UX).
        await fetchEntries();
        markProfileChanged(); // Invalidate analytics cache
        navigate(location.pathname, {
          replace: true,
          state: { success: "Employment entry deleted successfully!" },
        });
      }
    } catch (e) {
      console.error("Delete failed", e);
      handleError(e);
    }
  };

  if (isLoading || loading) return <LoadingSpinner />;

  return (
    <Box sx={{ width: "100%", minHeight: "100vh", p: 3 }}>
      <Breadcrumbs
    setDialogMode("edit");
    setSelectedEntry(entry);
    setDialogOpen(true);
  };

  const handleCloseDialog = () => {
    setDialogOpen(false);
    setSelectedEntry(undefined);
  };

  const handleDialogSuccess = () => {
    fetchEntries();
  };

  const handleDelete = async (entryId: string) {
    // Confirm deletion with user using hook-based dialog
    const confirmed = await confirm({
      title: "Delete employment entry?",
      message: "This will permanently delete the selected employment entry.",
      confirmText: "Delete",
      confirmColor: "error",
    });

    if (!confirmed) return;

    if (!user) {
      handleError("Please sign in to delete entries.");
      return;
    }

    try {
      const res = await employmentService.deleteEmployment(user.id, entryId);
      if (res.error) {
        console.error(res.error);
        handleError(res.error);
      } else {
        // After a successful deletion, refresh the list so the UI reflects
        // the backend state. Then set navigation state so the list page shows
        // a centralized success snackbar (consistent notification UX).
        await fetchEntries();
        markProfileChanged(); // Invalidate analytics cache
        navigate(location.pathname, {
          replace: true,
          state: { success: "Employment entry deleted successfully!" },
        });
      }
    } catch (e) {
      console.error("Delete failed", e);
      handleError(e);
    }
  };

  if (isLoading || loading) return <LoadingSpinner />;

  return (
    <Box sx={{ width: "100%", minHeight: "100vh", p: 3 }}>
      <Breadcrumbs
        items={[
          { label: "Profile", path: "/profile" },
          { label: "Employment" },
        ]}
      />
      <Box
        sx={{
          display: "flex",
          justifyContent: "space-between",
          alignItems: "center",
          mb: 2,
        }}
      >
        <Typography variant="h4">Employment History</Typography>
        <Button
          variant="contained"
          color="primary"
          onClick={handleOpenAddDialog}
        >
          Add Employment
        </Button>
      </Box>

      {entries !== null && entries.length === 0 && (
        <EmptyState
          icon={<WorkIcon />}
          title="No employment entries yet"
          description="Click 'Add Employment' to start building your work history"
          action={
            <Button
              variant="contained"
              onClick={handleOpenAddDialog}
            >
              Add Employment
            </Button>
          }
        />
      )}

      <Stack spacing={2} mt={2}>
        {(entries ?? []).map((entry) => (
          <Paper key={entry.id} variant="outlined" sx={{ p: 2 }}>
            <Box
              sx={{
                display: "flex",
                justifyContent: "space-between",
                alignItems: "center",
                gap: 2,
              }}
            >
              <Box>
                <Typography variant="h6">
                  {entry.job_title} @ {entry.company_name}
                </Typography>
                <Typography variant="body2" color="text.secondary">
                  {entry.location} •{" "}
                  {entry.current_position
                    ? "Present"
                    : `${entry.start_date} – ${entry.end_date}`}
                </Typography>
              </Box>
              <Box sx={{ display: "flex", gap: 1 }}>
                <Button
                  variant="text"
                  color="primary"
                  onClick={() => handleOpenEditDialog(entry)}
                >
                  Edit
                </Button>
                <Button
                  variant="text"
                  color="error"
                  onClick={() => handleDelete(entry.id)}
                >
                  Delete
                </Button>
              </Box>
            </Box>

            {entry.job_description && (
              <Typography variant="body2" color="text.primary" sx={{ mt: 1 }}>
                Job Description: {entry.job_description}
              </Typography>
            )}
          </Paper>
        ))}
      </Stack>

      {/* Add/Edit Dialog */}
      <AddEmploymentDialog
        open={dialogOpen}
        onClose={handleCloseDialog}
        onSuccess={handleDialogSuccess}
        mode={dialogMode}
        existingEntry={selectedEntry}
      />
      
      <ErrorSnackbar notification={notification} onClose={closeNotification} />
    </Box>
  );
}
