/**
 * PROGRESS SHARING SERVICE (UC-111)
 *
 * Handles all database operations for progress sharing and accountability.
 * Uses direct Supabase access with RLS enforcement.
 *
 * Purpose:
 * - Manage privacy settings for progress sharing
 * - Generate and retrieve progress snapshots
 * - Manage accountability partnerships
 * - Track and create achievement celebrations
 *
 * Security:
 * - All operations scoped by authenticated user
 * - RLS policies enforce visibility permissions
 * - Privacy settings respected for all data access
 */

import { supabase } from "@shared/services/supabaseClient";
import type { Result } from "@shared/services/types";

// ============================================================================
// TYPE DEFINITIONS
// ============================================================================

/**
 * Visibility levels for progress sharing
 */
export type SharingVisibility =
  | "private"
  | "mentors_only"
  | "accountability"
  | "team"
  | "public";

/**
 * Types of achievement celebrations
 */
export type CelebrationType =
  | "first_application"
  | "application_milestone"
  | "first_interview"
  | "interview_milestone"
  | "goal_completed"
  | "streak_achieved"
  | "offer_received"
  | "offer_accepted"
  | "document_approved"
  | "weekly_target_met"
  | "monthly_target_met"
  | "custom";

/**
 * Status of accountability partnerships
 */
export type PartnershipStatus = "pending" | "active" | "paused" | "ended";

/**
 * Progress sharing settings for a user
 */
export interface ProgressSharingSettings {
  id: string;
  userId: string;
  teamId: string;
  visibility: SharingVisibility;
  shareApplications: boolean;
  shareInterviews: boolean;
  shareOffers: boolean;
  shareGoals: boolean;
  shareActivityTimeline: boolean;
  shareDocuments: boolean;
  notifyOnView: boolean;
  notifyOnCelebration: boolean;
  notifyWeeklySummary: boolean;
  showOnTeamLeaderboard: boolean;
  allowEncouragement: boolean;
  createdAt: string;
  updatedAt: string;
}

/**
 * Data for creating/updating sharing settings
 */
export interface UpdateSharingSettingsData {
  visibility?: SharingVisibility;
  shareApplications?: boolean;
  shareInterviews?: boolean;
  shareOffers?: boolean;
  shareGoals?: boolean;
  shareActivityTimeline?: boolean;
  shareDocuments?: boolean;
  notifyOnView?: boolean;
  notifyOnCelebration?: boolean;
  notifyWeeklySummary?: boolean;
  showOnTeamLeaderboard?: boolean;
  allowEncouragement?: boolean;
}

/**
 * Progress snapshot data
 */
export interface ProgressSnapshot {
  id: string;
  userId: string;
  teamId: string;
  snapshotDate: string;
  periodType: "daily" | "weekly" | "monthly";
  periodStart: string;
  periodEnd: string;
  applicationsTotal: number;
  applicationsThisPeriod: number;
  applicationsByStatus: Record<string, number>;
  interviewsScheduled: number;
  interviewsCompleted: number;
  interviewsThisPeriod: number;
  offersReceived: number;
  offersThisPeriod: number;
  goalsTotal: number;
  goalsCompleted: number;
  goalsCompletionRate: number;
  activityScore: number;
  streakDays: number;
  applicationsTrend: number;
  interviewsTrend: number;
  activityTrend: number;
  dailyBreakdown: Array<{
    date: string;
    applications: number;
    interviews: number;
  }>;
  createdAt: string;
}

/**
 * Accountability partnership data
 */
export interface AccountabilityPartnership {
  id: string;
  teamId: string;
  userId: string;
  partnerId: string;
  status: PartnershipStatus;
  initiatedBy: string;
  invitationMessage?: string;
  lastInteractionAt?: string;
  interactionCount: number;
  encouragementSent: number;
  encouragementReceived: number;
  effectivenessScore: number;
  createdAt: string;
  updatedAt: string;
  acceptedAt?: string;
  endedAt?: string;
  // Joined data
  partner?: {
    fullName: string;
    email: string;
    professionalTitle?: string;
  };
  user?: {
    fullName: string;
    email: string;
    professionalTitle?: string;
  };
}

/**
 * Achievement celebration data
 */
export interface AchievementCelebration {
  id: string;
  teamId: string;
  userId: string;
  celebrationType: CelebrationType;
  title: string;
  description?: string;
  milestoneValue?: number;
  relatedJobId?: number;
  relatedGoalId?: string;
  createdBy?: string;
  isAutoGenerated: boolean;
  isShared: boolean;
  isDismissed: boolean;
  reactions: Array<{
    userId: string;
    emoji: string;
    message?: string;
    createdAt: string;
  }>;
  celebratedAt: string;
  createdAt: string;
  // Joined data
  user?: {
    fullName: string;
    email: string;
  };
}

/**
 * Data for creating a partnership request
 */
export interface CreatePartnershipData {
  teamId: string;
  partnerId: string;
  invitationMessage?: string;
}

/**
 * Data for creating a custom celebration
 */
export interface CreateCelebrationData {
  teamId: string;
  userId: string;
  celebrationType: CelebrationType;
  title: string;
  description?: string;
  milestoneValue?: number;
  relatedJobId?: number;
  relatedGoalId?: string;
}

/**
 * Reaction data for celebrations
 */
export interface ReactionData {
  emoji: string;
  message?: string;
}

// ============================================================================
// PROGRESS SHARING SETTINGS OPERATIONS
// ============================================================================

/**
 * Get user's progress sharing settings for a team
 * Creates default settings if none exist
 */
export async function getProgressSharingSettings(
  userId: string,
  teamId: string
): Promise<Result<ProgressSharingSettings>> {
  const { data, error } = await supabase
    .from("progress_sharing_settings")
    .select("*")
    .eq("user_id", userId)
    .eq("team_id", teamId)
    .single();

  if (error && error.code === "PGRST116") {
    // No settings found, create defaults
    return createDefaultSharingSettings(userId, teamId);
  }

  if (error) {
    return {
      data: null,
      error: { message: error.message, status: null },
      status: null,
    };
  }

  return {
    data: mapSettingsFromDb(data),
    error: null,
    status: 200,
  };
}

/**
 * Create default sharing settings for a user
 */
async function createDefaultSharingSettings(
  userId: string,
  teamId: string
): Promise<Result<ProgressSharingSettings>> {
  const { data, error } = await supabase
    .from("progress_sharing_settings")
    .insert({
      user_id: userId,
      team_id: teamId,
      visibility: "mentors_only",
      share_applications: true,
      share_interviews: true,
      share_offers: true,
      share_goals: true,
      share_activity_timeline: false,
      share_documents: false,
      notify_on_view: false,
      notify_on_celebration: true,
      notify_weekly_summary: true,
      show_on_team_leaderboard: false,
      allow_encouragement: true,
    })
    .select()
    .single();

  if (error) {
    return {
      data: null,
      error: { message: error.message, status: null },
      status: null,
    };
  }

  return {
    data: mapSettingsFromDb(data),
    error: null,
    status: 201,
  };
}

/**
 * Update user's progress sharing settings
 */
export async function updateProgressSharingSettings(
  userId: string,
  teamId: string,
  updates: UpdateSharingSettingsData
): Promise<Result<ProgressSharingSettings>> {
  // Map camelCase to snake_case for database
  const dbUpdates: Record<string, unknown> = {};
  if (updates.visibility !== undefined)
    dbUpdates.visibility = updates.visibility;
  if (updates.shareApplications !== undefined)
    dbUpdates.share_applications = updates.shareApplications;
  if (updates.shareInterviews !== undefined)
    dbUpdates.share_interviews = updates.shareInterviews;
  if (updates.shareOffers !== undefined)
    dbUpdates.share_offers = updates.shareOffers;
  if (updates.shareGoals !== undefined)
    dbUpdates.share_goals = updates.shareGoals;
  if (updates.shareActivityTimeline !== undefined)
    dbUpdates.share_activity_timeline = updates.shareActivityTimeline;
  if (updates.shareDocuments !== undefined)
    dbUpdates.share_documents = updates.shareDocuments;
  if (updates.notifyOnView !== undefined)
    dbUpdates.notify_on_view = updates.notifyOnView;
  if (updates.notifyOnCelebration !== undefined)
    dbUpdates.notify_on_celebration = updates.notifyOnCelebration;
  if (updates.notifyWeeklySummary !== undefined)
    dbUpdates.notify_weekly_summary = updates.notifyWeeklySummary;
  if (updates.showOnTeamLeaderboard !== undefined)
    dbUpdates.show_on_team_leaderboard = updates.showOnTeamLeaderboard;
  if (updates.allowEncouragement !== undefined)
    dbUpdates.allow_encouragement = updates.allowEncouragement;

  const { data, error } = await supabase
    .from("progress_sharing_settings")
    .update(dbUpdates)
    .eq("user_id", userId)
    .eq("team_id", teamId)
    .select()
    .single();

  if (error) {
    return {
      data: null,
      error: { message: error.message, status: null },
      status: null,
    };
  }

  return {
    data: mapSettingsFromDb(data),
    error: null,
    status: 200,
  };
}

// ============================================================================
// PROGRESS SNAPSHOT OPERATIONS
// ============================================================================

/**
 * Get user's progress snapshots
 */
export async function getProgressSnapshots(
  userId: string,
  teamId: string,
  options: {
    periodType?: "daily" | "weekly" | "monthly";
    limit?: number;
  } = {}
): Promise<Result<ProgressSnapshot[]>> {
  let query = supabase
    .from("progress_snapshots")
    .select("*")
    .eq("user_id", userId)
    .eq("team_id", teamId)
    .order("snapshot_date", { ascending: false });

  if (options.periodType) {
    query = query.eq("period_type", options.periodType);
  }

  if (options.limit) {
    query = query.limit(options.limit);
  }

  const { data, error } = await query;

  if (error) {
    return {
      data: null,
      error: { message: error.message, status: null },
      status: null,
    };
  }

  return {
    data: data.map(mapSnapshotFromDb),
    error: null,
    status: 200,
  };
}

/**
 * Get latest progress snapshot for a user
 */
export async function getLatestSnapshot(
  userId: string,
  teamId: string
): Promise<Result<ProgressSnapshot | null>> {
  const { data, error } = await supabase
    .from("progress_snapshots")
    .select("*")
    .eq("user_id", userId)
    .eq("team_id", teamId)
    .order("snapshot_date", { ascending: false })
    .limit(1)
    .single();

  if (error && error.code === "PGRST116") {
    // No snapshot found
    return { data: null, error: null, status: 200 };
  }

  if (error) {
    return {
      data: null,
      error: { message: error.message, status: null },
      status: null,
    };
  }

  return {
    data: mapSnapshotFromDb(data),
    error: null,
    status: 200,
  };
}

/**
 * Create a new progress snapshot using the database function
 */
export async function createProgressSnapshot(
  userId: string,
  teamId: string,
  periodType: "daily" | "weekly" | "monthly" = "weekly"
): Promise<Result<string>> {
  const { data, error } = await supabase.rpc("create_progress_snapshot", {
    p_user_id: userId,
    p_team_id: teamId,
    p_period_type: periodType,
  });

  if (error) {
    return {
      data: null,
      error: { message: error.message, status: null },
      status: null,
    };
  }

  return {
    data: data as string,
    error: null,
    status: 201,
  };
}

/**
 * Get progress summary using the database function
 * Respects privacy settings for the viewer
 */
export async function getProgressSummary(
  userId: string,
  teamId: string,
  viewerId?: string
): Promise<Result<Record<string, unknown>>> {
  const { data, error } = await supabase.rpc("get_user_progress_summary", {
    p_user_id: userId,
    p_team_id: teamId,
    p_viewer_id: viewerId || null,
  });

  if (error) {
    return {
      data: null,
      error: { message: error.message, status: null },
      status: null,
    };
  }

  // Check for permission error in response
  if (data?.error) {
    return {
      data: null,
      error: { message: data.error, status: 403 },
      status: 403,
    };
  }

  return {
    data: data as Record<string, unknown>,
    error: null,
    status: 200,
  };
}

// ============================================================================
// ACCOUNTABILITY PARTNERSHIP OPERATIONS
// ============================================================================

/**
 * Get user's accountability partnerships
 * Returns both partnerships where user is the candidate and where they're the partner
 */
export async function getAccountabilityPartnerships(
  userId: string,
  teamId?: string
): Promise<Result<AccountabilityPartnership[]>> {
  let query = supabase
    .from("accountability_partnerships")
    .select(
      `
      *,
      partner:profiles!partner_id(full_name, email, professional_title),
      user:profiles!user_id(full_name, email, professional_title)
    `
    )
    .or(`user_id.eq.${userId},partner_id.eq.${userId}`)
    .order("created_at", { ascending: false });

  if (teamId) {
    query = query.eq("team_id", teamId);
  }

  const { data, error } = await query;

  if (error) {
    return {
      data: null,
      error: { message: error.message, status: null },
      status: null,
    };
  }

  return {
    data: data.map(mapPartnershipFromDb),
    error: null,
    status: 200,
  };
}

/**
 * Get active partnerships for a user
 */
export async function getActivePartnerships(
  userId: string,
  teamId: string
): Promise<Result<AccountabilityPartnership[]>> {
  const { data, error } = await supabase
    .from("accountability_partnerships")
    .select(
      `
      *,
      partner:profiles!partner_id(full_name, email, professional_title),
      user:profiles!user_id(full_name, email, professional_title)
    `
    )
    .or(`user_id.eq.${userId},partner_id.eq.${userId}`)
    .eq("team_id", teamId)
    .eq("status", "active")
    .order("created_at", { ascending: false });

  if (error) {
    return {
      data: null,
      error: { message: error.message, status: null },
      status: null,
    };
  }

  return {
    data: data.map(mapPartnershipFromDb),
    error: null,
    status: 200,
  };
}

/**
 * Create a new accountability partnership request
 */
export async function createPartnershipRequest(
  userId: string,
  data: CreatePartnershipData
): Promise<Result<AccountabilityPartnership>> {
  const { data: result, error } = await supabase
    .from("accountability_partnerships")
    .insert({
      team_id: data.teamId,
      user_id: userId, // The candidate requesting
      partner_id: data.partnerId,
      initiated_by: userId,
      invitation_message: data.invitationMessage || null,
      status: "pending",
    })
    .select(
      `
      *,
      partner:profiles!partner_id(full_name, email, professional_title),
      user:profiles!user_id(full_name, email, professional_title)
    `
    )
    .single();

  if (error) {
    return {
      data: null,
      error: { message: error.message, status: null },
      status: null,
    };
  }

  return {
    data: mapPartnershipFromDb(result),
    error: null,
    status: 201,
  };
}

/**
 * Accept a partnership invitation
 */
export async function acceptPartnership(
  partnershipId: string
): Promise<Result<AccountabilityPartnership>> {
  const { data, error } = await supabase
    .from("accountability_partnerships")
    .update({
      status: "active",
      accepted_at: new Date().toISOString(),
    })
    .eq("id", partnershipId)
    .select(
      `
      *,
      partner:profiles!partner_id(full_name, email, professional_title),
      user:profiles!user_id(full_name, email, professional_title)
    `
    )
    .single();

  if (error) {
    return {
      data: null,
      error: { message: error.message, status: null },
      status: null,
    };
  }

  return {
    data: mapPartnershipFromDb(data),
    error: null,
    status: 200,
  };
}

/**
 * Decline or end a partnership
 */
export async function endPartnership(
  partnershipId: string
): Promise<Result<boolean>> {
  const { error } = await supabase
    .from("accountability_partnerships")
    .update({
      status: "ended",
      ended_at: new Date().toISOString(),
    })
    .eq("id", partnershipId);

  if (error) {
    return {
      data: null,
      error: { message: error.message, status: null },
      status: null,
    };
  }

  return { data: true, error: null, status: 200 };
}

/**
 * Record an interaction with a partner (for engagement tracking)
 */
export async function recordPartnerInteraction(
  partnershipId: string,
  isEncouragement: boolean = false
): Promise<Result<boolean>> {
  // Get current values
  const { data: current, error: fetchError } = await supabase
    .from("accountability_partnerships")
    .select("interaction_count, encouragement_sent, encouragement_received")
    .eq("id", partnershipId)
    .single();

  if (fetchError) {
    return {
      data: null,
      error: { message: fetchError.message, status: null },
      status: null,
    };
  }

  const updates: Record<string, unknown> = {
    last_interaction_at: new Date().toISOString(),
    interaction_count: (current.interaction_count || 0) + 1,
  };

  if (isEncouragement) {
    updates.encouragement_sent = (current.encouragement_sent || 0) + 1;
  }

  const { error } = await supabase
    .from("accountability_partnerships")
    .update(updates)
    .eq("id", partnershipId);

  if (error) {
    return {
      data: null,
      error: { message: error.message, status: null },
      status: null,
    };
  }

  return { data: true, error: null, status: 200 };
}

// ============================================================================
// ACHIEVEMENT CELEBRATION OPERATIONS
// ============================================================================

/**
 * Get user's achievements/celebrations
 */
export async function getAchievements(
  userId: string,
  teamId?: string,
  options: {
    includeSharedOnly?: boolean;
    limit?: number;
  } = {}
): Promise<Result<AchievementCelebration[]>> {
  let query = supabase
    .from("achievement_celebrations")
    .select(
      `
      *,
      user:profiles!user_id(full_name, email)
    `
    )
    .eq("user_id", userId)
    .eq("is_dismissed", false)
    .order("celebrated_at", { ascending: false });

  if (teamId) {
    query = query.eq("team_id", teamId);
  }

  if (options.includeSharedOnly) {
    query = query.eq("is_shared", true);
  }

  if (options.limit) {
    query = query.limit(options.limit);
  }

  const { data, error } = await query;

  if (error) {
    return {
      data: null,
      error: { message: error.message, status: null },
      status: null,
    };
  }

  return {
    data: data.map(mapCelebrationFromDb),
    error: null,
    status: 200,
  };
}

/**
 * Get team's shared achievements (for team dashboard)
 */
export async function getTeamAchievements(
  teamId: string,
  limit: number = 20
): Promise<Result<AchievementCelebration[]>> {
  const { data, error } = await supabase
    .from("achievement_celebrations")
    .select(
      `
      *,
      user:profiles!user_id(full_name, email)
    `
    )
    .eq("team_id", teamId)
    .eq("is_shared", true)
    .eq("is_dismissed", false)
    .order("celebrated_at", { ascending: false })
    .limit(limit);

  if (error) {
    return {
      data: null,
      error: { message: error.message, status: null },
      status: null,
    };
  }

  return {
    data: data.map(mapCelebrationFromDb),
    error: null,
    status: 200,
  };
}

/**
 * Create a custom celebration (by mentor or user)
 */
export async function createCelebration(
  createdBy: string,
  data: CreateCelebrationData
): Promise<Result<AchievementCelebration>> {
  const { data: result, error } = await supabase
    .from("achievement_celebrations")
    .insert({
      team_id: data.teamId,
      user_id: data.userId,
      celebration_type: data.celebrationType,
      title: data.title,
      description: data.description || null,
      milestone_value: data.milestoneValue || null,
      related_job_id: data.relatedJobId || null,
      related_goal_id: data.relatedGoalId || null,
      created_by: createdBy,
      is_auto_generated: false,
      is_shared: true,
    })
    .select(
      `
      *,
      user:profiles!user_id(full_name, email)
    `
    )
    .single();

  if (error) {
    return {
      data: null,
      error: { message: error.message, status: null },
      status: null,
    };
  }

  return {
    data: mapCelebrationFromDb(result),
    error: null,
    status: 201,
  };
}

/**
 * Add a reaction to a celebration
 */
export async function addReaction(
  celebrationId: string,
  userId: string,
  reaction: ReactionData
): Promise<Result<boolean>> {
  // Get current reactions
  const { data: celebration, error: fetchError } = await supabase
    .from("achievement_celebrations")
    .select("reactions")
    .eq("id", celebrationId)
    .single();

  if (fetchError) {
    return {
      data: null,
      error: { message: fetchError.message, status: null },
      status: null,
    };
  }

  const currentReactions = (celebration.reactions as Array<unknown>) || [];

  // Add new reaction
  const newReaction = {
    user_id: userId,
    emoji: reaction.emoji,
    message: reaction.message || null,
    created_at: new Date().toISOString(),
  };

  const { error } = await supabase
    .from("achievement_celebrations")
    .update({
      reactions: [...currentReactions, newReaction],
    })
    .eq("id", celebrationId);

  if (error) {
    return {
      data: null,
      error: { message: error.message, status: null },
      status: null,
    };
  }

  return { data: true, error: null, status: 200 };
}

/**
 * Dismiss a celebration (user no longer wants to see it)
 */
export async function dismissCelebration(
  celebrationId: string
): Promise<Result<boolean>> {
  const { error } = await supabase
    .from("achievement_celebrations")
    .update({ is_dismissed: true })
    .eq("id", celebrationId);

  if (error) {
    return {
      data: null,
      error: { message: error.message, status: null },
      status: null,
    };
  }

  return { data: true, error: null, status: 200 };
}

/**
 * Trigger achievement check using database function
 */
export async function checkAndCreateAchievement(
  userId: string,
  teamId: string,
  eventType: string,
  eventValue?: number
): Promise<Result<string | null>> {
  const { data, error } = await supabase.rpc("check_and_create_achievement", {
    p_user_id: userId,
    p_team_id: teamId,
    p_event_type: eventType,
    p_event_value: eventValue || null,
  });

  if (error) {
    return {
      data: null,
      error: { message: error.message, status: null },
      status: null,
    };
  }

  return {
    data: data as string | null,
    error: null,
    status: 200,
  };
}

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

/**
 * Map database row to ProgressSharingSettings
 */
function mapSettingsFromDb(
  row: Record<string, unknown>
): ProgressSharingSettings {
  return {
    id: row.id as string,
    userId: row.user_id as string,
    teamId: row.team_id as string,
    visibility: row.visibility as SharingVisibility,
    shareApplications: row.share_applications as boolean,
    shareInterviews: row.share_interviews as boolean,
    shareOffers: row.share_offers as boolean,
    shareGoals: row.share_goals as boolean,
    shareActivityTimeline: row.share_activity_timeline as boolean,
    shareDocuments: row.share_documents as boolean,
    notifyOnView: row.notify_on_view as boolean,
    notifyOnCelebration: row.notify_on_celebration as boolean,
    notifyWeeklySummary: row.notify_weekly_summary as boolean,
    showOnTeamLeaderboard: row.show_on_team_leaderboard as boolean,
    allowEncouragement: row.allow_encouragement as boolean,
    createdAt: row.created_at as string,
    updatedAt: row.updated_at as string,
  };
}

/**
 * Map database row to ProgressSnapshot
 */
function mapSnapshotFromDb(row: Record<string, unknown>): ProgressSnapshot {
  return {
    id: row.id as string,
    userId: row.user_id as string,
    teamId: row.team_id as string,
    snapshotDate: row.snapshot_date as string,
    periodType: row.period_type as "daily" | "weekly" | "monthly",
    periodStart: row.period_start as string,
    periodEnd: row.period_end as string,
    applicationsTotal: row.applications_total as number,
    applicationsThisPeriod: row.applications_this_period as number,
    applicationsByStatus: row.applications_by_status as Record<string, number>,
    interviewsScheduled: row.interviews_scheduled as number,
    interviewsCompleted: row.interviews_completed as number,
    interviewsThisPeriod: row.interviews_this_period as number,
    offersReceived: row.offers_received as number,
    offersThisPeriod: row.offers_this_period as number,
    goalsTotal: row.goals_total as number,
    goalsCompleted: row.goals_completed as number,
    goalsCompletionRate: row.goals_completion_rate as number,
    activityScore: row.activity_score as number,
    streakDays: row.streak_days as number,
    applicationsTrend: row.applications_trend as number,
    interviewsTrend: row.interviews_trend as number,
    activityTrend: row.activity_trend as number,
    dailyBreakdown: row.daily_breakdown as Array<{
      date: string;
      applications: number;
      interviews: number;
    }>,
    createdAt: row.created_at as string,
  };
}

/**
 * Map database row to AccountabilityPartnership
 */
function mapPartnershipFromDb(
  row: Record<string, unknown>
): AccountabilityPartnership {
  const partnerData = row.partner as Record<string, unknown> | null;
  const userData = row.user as Record<string, unknown> | null;

  return {
    id: row.id as string,
    teamId: row.team_id as string,
    userId: row.user_id as string,
    partnerId: row.partner_id as string,
    status: row.status as PartnershipStatus,
    initiatedBy: row.initiated_by as string,
    invitationMessage: row.invitation_message as string | undefined,
    lastInteractionAt: row.last_interaction_at as string | undefined,
    interactionCount: row.interaction_count as number,
    encouragementSent: row.encouragement_sent as number,
    encouragementReceived: row.encouragement_received as number,
    effectivenessScore: row.effectiveness_score as number,
    createdAt: row.created_at as string,
    updatedAt: row.updated_at as string,
    acceptedAt: row.accepted_at as string | undefined,
    endedAt: row.ended_at as string | undefined,
    partner: partnerData
      ? {
          fullName: partnerData.full_name as string,
          email: partnerData.email as string,
          professionalTitle: partnerData.professional_title as
            | string
            | undefined,
        }
      : undefined,
    user: userData
      ? {
          fullName: userData.full_name as string,
          email: userData.email as string,
          professionalTitle: userData.professional_title as string | undefined,
        }
      : undefined,
  };
}

/**
 * Map database row to AchievementCelebration
 */
function mapCelebrationFromDb(
  row: Record<string, unknown>
): AchievementCelebration {
  const userData = row.user as Record<string, unknown> | null;

  return {
    id: row.id as string,
    teamId: row.team_id as string,
    userId: row.user_id as string,
    celebrationType: row.celebration_type as CelebrationType,
    title: row.title as string,
    description: row.description as string | undefined,
    milestoneValue: row.milestone_value as number | undefined,
    relatedJobId: row.related_job_id as number | undefined,
    relatedGoalId: row.related_goal_id as string | undefined,
    createdBy: row.created_by as string | undefined,
    isAutoGenerated: row.is_auto_generated as boolean,
    isShared: row.is_shared as boolean,
    isDismissed: row.is_dismissed as boolean,
    reactions:
      (row.reactions as Array<{
        userId: string;
        emoji: string;
        message?: string;
        createdAt: string;
      }>) || [],
    celebratedAt: row.celebrated_at as string,
    createdAt: row.created_at as string,
    user: userData
      ? {
          fullName: userData.full_name as string,
          email: userData.email as string,
        }
      : undefined,
  };
}
